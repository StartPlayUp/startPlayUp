Index: backend/Common/fireBaseDB/user.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const { checkRoomStructure, checkUsersStructure } = require('./Constant/checkStructure');\nconst { isString, isObject, isBoolean, isArray } = require('./Constant/checkTypeOrEmpty');\nconst admin = require('firebase-admin');\nconst FieldValue = admin.firestore.FieldValue;\nconst db = admin.firestore();\n\nexports.isDuplicateNicknameAndEmail = async ({ nickname, email }) => {\n    let duplicate = false;\n    let userList = [];\n    if (isString(nickname) &&\n        isString(email)) {\n        const userRef = db.collection('users');\n        const snapshot1 = await userRef.where('nickname', \"==\", nickname).get();\n        console.log(snapshot1.empty)\n        if (!snapshot1.empty) {\n            duplicate = true;\n            snapshot1.forEach(doc => {\n                userList.push(doc.data());\n            });\n            console.log(userList)\n        }\n\n        const snapshot2 = await userRef.where('email', '==', email).get();\n        console.log(snapshot2.empty)\n        if (!snapshot2.empty) {\n            duplicate = true;\n            snapshot2.forEach(doc => {\n                userList.push(doc.data());\n            });\n            console.log(userList)\n        }\n    }\n    else {\n        console.error(\"isDuplicateNicknameAndEmail error\");\n    }\n    return { userList, duplicate };\n}\n\nexports.isDuplicateNickname = async ({ nickname }) => {\n    let duplicate = false;\n    let userList = [];\n    if (isString(nickname)) {\n        const userRef = db.collection('users');\n        const snapshot = await userRef.where('nickname', \"==\", nickname).get();\n        console.log(snapshot.empty)\n        if (!snapshot.empty) {\n            duplicate = true;\n            snapshot.forEach(doc => {\n                userList.push(doc.data());\n            });\n            console.log(userList)\n        }\n    }\n    else {\n        console.error(\"isDuplicateNickname error\");\n    }\n    return { userList, duplicate };\n}\n\nexports.isDuplicateEmail = async ({ email }) => {\n    let duplicate = false;\n    let userList = [];\n    if (isString(email)) {\n        const userRef = db.collection('users');\n        const snapshot = await userRef.where('email', '==', email).get();\n        console.log(snapshot.empty)\n        if (!snapshot.empty) {\n            duplicate = true;\n            snapshot.forEach(doc => {\n                userList.push(doc.data());\n            });\n            console.log(userList)\n        }\n    }\n    else {\n        console.error(\"isDuplicateEmail error\");\n    }\n    return { userList, duplicate };\n}\n\nexports.createUser = async ({ user }) => {\n    try {\n        // console.log(user)\n        const usingSns = false;\n        const sns = {\n            provider: \"\",\n            id: \"\",\n        }\n        const report = {\n            count: 0,\n            time: 0,\n        }\n        const numberOfGames = {\n            win: 0,\n            lose: 0,\n        }\n        if (checkUsersStructure(user)) {\n            const {\n                nickname,\n                email,\n                password,\n            } = user;\n            // if (!(await this.isDuplicateNicknameAndEmail({ nickname, email })).duplicate) { // 둘다 체크할 때\n            if (!(await this.isDuplicateEmail({ email })).duplicate) {\n                // const res = db.collection(\"users\").doc(nickname);\n                const res = db.collection(\"users\");\n                const setReturn = await res.add({\n                    nickname,\n                    email,\n                    password,\n                    usingSns,\n                    sns,\n                    numberOfGames,\n                    report,\n                    timestamp: FieldValue.serverTimestamp(),\n                });\n                // const updateReturn = await res.update({ timestamp: FieldValue.serverTimestamp() })\n                // console.log(setReturn, updateReturn)\n                return { success: true }\n            }\n            else {\n                return { success: false }\n            }\n        }\n        else {\n            console.error(\"createUsersArgumentCheck error\");\n            return { success: false }\n        }\n    }\n    catch (error) {\n        console.error(error);\n        return { success: false }\n    }\n\n}\n\n\nexports.createUserForSns = async ({ user }) => {\n    try {\n        // console.log(user)\n        let docId = undefined;\n        const usingSns = true;\n        const report = {\n            const: 0,\n            time: 0,\n        }\n        const numberOfGames = {\n            win: 0,\n            lose: 0,\n        }\n        const {\n            nickname,\n            email,\n            sns,\n        } = user;\n        if (isString(email) &&\n            isObject(sns) &&\n            isString(nickname)) {\n            if (!(await this.isDuplicateEmail({ email: user.email })).duplicate) {\n                // const res = db.collection(\"users\").doc(nickname);\n                const res = db.collection(\"users\");\n                const setReturn = await res.add({\n                    // nickname: \"\",\n                    nickname,\n                    email,\n                    password: false,\n                    usingSns,\n                    sns,\n                    numberOfGames,\n                    report,\n                    timestamp: FieldValue.serverTimestamp(),\n                });\n                docId = setReturn.id\n                // console.log(\"아이디 만들때 \", setReturn.id)\n                return { success: true, docId }\n            }\n            else {\n                return { success: false, docId }\n            }\n        }\n        else {\n            console.error(\"createUserForSns ArgumentCheck error\");\n            return { success: false }\n        }\n    }\n    catch (error) {\n        console.error(error);\n        return { success: false }\n    }\n\n}\n\nexports.deleteUserFromEmail = async ({ email }) => {\n    // 수정중\n    let success = false;\n    try {\n        console.log(email)\n        if (isString(email)) {\n            console.log(\"email\")\n            const result = await db.collection('users').where(\"email\", \"==\", email).get();\n            if (!result.empty) {\n                result.forEach((doc) => {\n                    doc.ref.delete()\n                })\n                success = true;\n            }\n        }\n        else {\n            console.error(\"deleteUserFromEmail error\");\n        }\n        return { success }\n    }\n    catch (error) {\n        console.error(error);\n        return { success }\n    }\n}\n\nexports.deleteUserFromNickname = async ({ nickname }) => {\n    let success = false;\n    try {\n        console.log(nickname);\n        if (isString(nickname)) {\n            const batch = db.batch();\n            const snapshot = await db.collection('users').where('nickname', '==', nickname).get();\n            snapshot.docs.forEach(async doc => {\n                batch.delete(doc.ref);\n                success = true;\n            });\n            await batch.commit();\n        }\n        else {\n            console.error(\"deleteUserFromNickname error\");\n        }\n        return { success };\n    }\n    catch (error) {\n        console.error(error);\n        return { success }\n    }\n}\n\n\n// exports.getUserFromEmail = async ({ email }) => {\n//     let success = false;\n//     let userList = [];\n//     if (isString(email)) {\n//         const userRef = db.collection('users');\n//         const result = await userRef.where('email', \"==\", email).get();\n//         if (!result.empty && result._size === 1) {\n//             success = true;\n//             result.forEach((doc) => {\n//                 const { report, numberOfGames, nickname, email, sns } = doc.data()\n//                 userList.push({ report, numberOfGames, nickname, email, sns })\n//             });\n//         }\n//     }\n//     else {\n//         console.error(\"getUserFromEmail error\");\n//     }\n//     return { user: userList[0], success };\n// }\n\nexports.getUserFromEmail = async ({ email }) => {\n    let success = false;\n    let userList = [];\n    if (isString(email)) {\n        const userRef = db.collection('users');\n        const result = await userRef.where('email', \"==\", email).get();\n        if (!result.empty && result._size === 1) {\n            success = true;\n            result.forEach((doc) => {\n                const { report, numberOfGames, nickname, email, sns } = doc.data()\n                if (nickname !== undefined && nickname !== \"\") {\n                    userList.push({ report, numberOfGames, nickname: nickname + \" \" + doc.id, email })\n                }\n            });\n        }\n    }\n    else {\n        console.error(\"getUserFromEmail error\");\n    }\n    return { user: userList[0], success };\n}\n\nexports.getUserFromNickname = async ({ nickname }) => {\n    let success = false;\n    let userList = [];\n    if (isString(nickname)) {\n        const userRef = db.collection('users');\n        const result = await userRef.where('nickname', \"==\", nickname).get();\n        if (!result.empty && result._size === 1) {\n            success = true;\n            result.forEach((doc) => {\n                const { report, numberOfGames, nickname, email } = doc.data()\n                userList.push({ report, numberOfGames, nickname, email })\n            });\n        }\n    }\n    else {\n        console.error(\"getUserFromNickname error\");\n    }\n    return { user: userList[0], success };\n}\n\nexports.updateUserReportCount = async ({ nickname }) => {\n    let success = false;\n    try {\n        console.log(isString(nickname))\n        if (isString(nickname) &&\n            nickname.split(' ').length === 2) {\n            const userRef = db.collection('users').doc(nickname.split(' ')[1]);\n            const result = await userRef.update({\n                [\"report.count\"]: FieldValue.increment(1),\n                [\"report.time\"]: FieldValue.serverTimestamp()\n            });\n            success = true;\n        }\n        else {\n            success = false;\n            console.error(\"updateUserReportCount error\");\n        }\n        return { success };\n    }\n    catch (error) {\n        return { success };\n    }\n}\n\n// 1. 회원 탈퇴 ??? 테스트해야하는데 front 만들어줘\n// 2. 전적 갱신 체크 \n// 3. getUser 세션기준 (입력값 없음) 체크\n// 4. peer 본인 삭제 불가 해결해보기. ???\n\nexports.updateGameResult = async ({ userList }) => {\n    let success = false;\n    const checkUserList = (user) => {\n        return isString(user.nickname) !== undefined && isBoolean(user.winner) !== undefined\n    }\n    try {\n        if (isObject(userList) &&\n            userList.length > 0 &&\n            userList.some(checkUserList)) {\n            const batch = db.batch();\n            const userRef = db.collection('users')\n            userList.forEach(async ({ nickname, winner }) => {\n                batch.update(userRef.doc(nickname.split(' ')[1]), {\n                    [`numberOfGames.${winner === true ? \"win\" : \"lose\"}`]: FieldValue.increment(1),\n                });\n            })\n            await batch.commit();\n            success = true;\n        }\n        else {\n            success = false;\n            console.error(\"updateNumberOfGames error\");\n        }\n        return { success };\n    }\n    catch (error) {\n        return { success };\n    }\n}\n\nexports.checkNicknameDuplication = async ({ nickname }) => {\n    let duplicateNickname = false;\n    let result = {};\n    if (isString(nickname)) {\n        const userRef = db.collection('users');\n        result = await userRef.where('nickname', \"==\", nickname).get();\n        if (!result.empty) {\n            duplicateNickname = true;\n        }\n    }\n    else {\n        console.error(\"checkNicknameDuplication error\");\n    }\n    return { duplicateNickname };\n}\n\nexports.checkEmailDuplication = async ({ email }) => {\n    console.log(email)\n    let duplicateEmail = false;\n    let result = {};\n    if (isString(email)) {\n        const userRef = db.collection('users');\n        result = await userRef.where('email', \"==\", email).get();\n        if (!result.empty) {\n            duplicateEmail = true;\n        }\n    }\n    else {\n        console.error(\"checkEmailDuplication error\");\n    }\n    return { duplicateEmail };\n}\n\nexports.checkLocalLogin = async ({ email, password }) => {\n    let success = false;\n    let user = {}\n    let docId = undefined;\n    try {\n        // console.log(\"checkLocalLogin function\");\n        if (isString(email) &&\n            isString(password)) {\n            const snapshot = await db.collection('users')\n                .where(\"email\", \"==\", email)\n                .where('password', '==', password)\n                .get();\n            // console.log(\"snapshot.empty && snapshot._size\", snapshot.empty, snapshot._size)\n            if (!snapshot.empty && snapshot._size === 1) {\n                snapshot.forEach(async doc => {\n                    success = true;\n                    const { password, sns, ...userForSend } = doc.data();\n                    user = userForSend;\n                    docId = doc.id;\n                });\n            }\n        }\n        else {\n            console.error(\"checkLocalLogin argument error\");\n        }\n        console.log(\"user\", user)\n        return { user, success, docId };\n    }\n    catch (err) {\n        return { user, success: false, docId };\n    }\n}\n\n\n\nexports.getSnsInUser = async ({ provider, id }) => {\n    let success = false;\n    let user = {};\n    let docId = \"\";\n    console.log(provider, id)\n    if (isString(provider) &&\n        isString(id)) {\n        const userRef = db.collection('users');\n        const result = await userRef.where(\"sns\", \"==\", { id, provider }).get();\n        result.forEach((doc) => {\n            success = true;\n            const { password, sns, ...userForSend } = doc.data();\n            user = userForSend;\n            docId = doc.id;\n        })\n    }\n    else {\n        console.error(\"getSnsInUser error\");\n    }\n    console.log(\"getSnsInUser : \", docId)\n    return { user, success, docId };\n}\n\nexports.joinSnsInUser = async ({ nickname, email, provider, id }) => {\n    try {\n        let success = false;\n        if (isString(email)) {\n            const batch = db.batch();\n            const snapshot = await db.collection('users')\n                .where(\"usingSns\", \"==\", false)\n                .where('nickname', '==', nickname)\n                .where(\"email\", \"==\", email)\n                .where(\"sns\", \"==\", { provider: \"\", id: \"\" })\n                .get();\n            if (snapshot.empty) {\n                snapshot.docs.forEach(async doc => {\n                    batch.update({ usingSns: true, sns: { provider, id } });\n                    success = true;\n                });\n                await batch.commit();\n            }\n        }\n        else {\n            console.error(\"joinSnsInUser argument error\");\n        }\n        return { success };\n    }\n    catch (err) {\n        return { success: false };\n    }\n}\n\n\nexports.setNickname = async ({ nickname, id, provider }) => {\n    let success = false;\n    try {\n        if (!await this.checkNicknameDuplication({ nickname }).duplicate) {\n            const resultGetSnsInUser = await this.getSnsInUser({ id, provider });\n            if (resultGetSnsInUser.success && resultGetSnsInUser.user.nickname === '') {\n                success = true;\n                const userRef = db.collection('users').doc(resultGetSnsInUser.docId);\n                await userRef.update({ nickname })\n            }\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n    return { success }\n}\n\n\nexports.disconnectSnsInUser = async ({ nickname, email }) => {\n    let duplicateEmail = false;\n    let result = {};\n    if (isString(email)) {\n        const userRef = db.collection('users');\n        result = await userRef.where('usingSns', \"==\", false)\n            .where(\"nickname\", \"array-contains\", { provider: \"\", id: \"\" }).get();\n        if (!result.empty) {\n            duplicateEmail = true;\n        }\n    }\n    else {\n        console.error(\"disconnectSnsInUser error\");\n    }\n    return { duplicateEmail };\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/Common/fireBaseDB/user.js b/backend/Common/fireBaseDB/user.js
--- a/backend/Common/fireBaseDB/user.js	(revision 8e7f3c6ea766a7ca7f223bff6400d9764dfbb96b)
+++ b/backend/Common/fireBaseDB/user.js	(date 1633329923086)
@@ -3,6 +3,8 @@
 const admin = require('firebase-admin');
 const FieldValue = admin.firestore.FieldValue;
 const db = admin.firestore();
+const crypto = require('crypto')
+const config = require('../../config');
 
 exports.isDuplicateNicknameAndEmail = async ({ nickname, email }) => {
     let duplicate = false;
@@ -79,6 +81,7 @@
 }
 
 exports.createUser = async ({ user }) => {
+
     try {
         // console.log(user)
         const usingSns = false;
@@ -103,11 +106,14 @@
             // if (!(await this.isDuplicateNicknameAndEmail({ nickname, email })).duplicate) { // 둘다 체크할 때
             if (!(await this.isDuplicateEmail({ email })).duplicate) {
                 // const res = db.collection("users").doc(nickname);
+                const encrypted = crypto.createHmac('sha512', config.secret)
+                    .update(password)
+                    .digest('base64')
                 const res = db.collection("users");
                 const setReturn = await res.add({
                     nickname,
                     email,
-                    password,
+                    password: encrypted,
                     usingSns,
                     sns,
                     numberOfGames,
@@ -403,9 +409,12 @@
         // console.log("checkLocalLogin function");
         if (isString(email) &&
             isString(password)) {
+            const encrypted = crypto.createHmac('sha512', config.secret)
+                .update(password)
+                .digest('base64')
             const snapshot = await db.collection('users')
                 .where("email", "==", email)
-                .where('password', '==', password)
+                .where('password', '==', encrypted)
                 .get();
             // console.log("snapshot.empty && snapshot._size", snapshot.empty, snapshot._size)
             if (!snapshot.empty && snapshot._size === 1) {
Index: backend/Common/fireBaseDB/room.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const { checkRoomStructure } = require('./Constant/checkStructure');\nconst { isString, isObject, isBoolean, isArray } = require('./Constant/checkTypeOrEmpty');\nconst admin = require('firebase-admin');\n\n\nconst db = admin.firestore();\n\nconst FieldValue = admin.firestore.FieldValue;\nconst crypto = require('crypto')\nconst config = require('../../config');\n\nexports.createRoom = async ({ room }) => {\n    try {\n        if (checkRoomStructure(room)) {\n            const {\n                hostname,\n                guestList,\n                roomTitle,\n                gameType,\n                play,\n                secret,\n                password,\n                roomLimit,\n            } = room;\n            const res = db.collection(\"rooms\");\n            const encrypted = crypto.createHmac('sha1', config.secret)\n                .update(password)\n                .digest('base64')\n            const addReturn = await res.add({\n                hostname,\n                guestList,\n                roomTitle,\n                gameType,\n                play,\n                secret,\n                password: encrypted,\n                roomLimit,\n                timestamp: FieldValue.serverTimestamp()\n            })\n            console.log(\"check room\")\n            return { roomId: addReturn.id, success: true };\n        } else {\n            return { roomId: \"\", success: false };\n        }\n    }\n    catch {\n        console.error(\"createRoom catch error\");\n        console.log(error)\n    }\n}\n\nexports.deleteRoom = async ({ roomId }) => {\n    if (isString(roomId)) {\n        const result = await db.collection('rooms').doc(roomId).delete();\n        console.log(result)\n    }\n    else {\n        console.error(\"deleteRoom error\");\n    }\n}\n\nexports.getListOfRooms = async () => {\n    const result = await db.collection('rooms').get()\n    const roomList = result.docs.map(doc => {\n        const { password, ...room } = doc.data();\n        return { ...room, roomId: doc.id }\n    })\n    return { roomList, success: !result.empty };\n}\n\nexports.getObjectOfRoom = async ({ roomId }) => {\n    let success = false;\n    let vacancy = false;\n    let room = {};\n    if (isString(roomId)) {\n        const result = await db.collection('rooms').doc(roomId).get();\n        const { password, ...roomWithoutPassword } = result.data();\n        room = roomWithoutPassword;\n        if (!result.empty) {\n            success = true;\n        }\n        console.log('getRoom-----------')\n        console.log(roomWithoutPassword.roomLimit)\n        console.log(roomWithoutPassword.guestList.length)\n        vacancy = roomWithoutPassword.roomLimit > roomWithoutPassword.guestList.length\n    }\n    else {\n        console.error(\"getObjectOfRoom error\");\n    }\n    return { roomObject: room, success, vacancy };\n}\n\nexports.joinRoom = async ({ roomId, nickname }) => {\n    try {\n        if (isString(roomId) &&\n            isString(nickname)) {\n            result = await db.collection('rooms').doc(roomId).update({\n                guestList: FieldValue.arrayUnion(nickname)\n            });\n            return { success: true };\n        }\n        else {\n            console.error(\"joinRoom error\");\n            return { success: false };\n        }\n    }\n    catch (error) {\n        console.error(error);\n        return { success: false };\n    }\n}\n\nexports.disconnectRoom = async ({ roomId, nickname }) => {\n    try {\n        if (isString(roomId) &&\n            isString(nickname)) {\n            result = await db.collection('rooms').doc(roomId).update({\n                guestList: FieldValue.arrayRemove(nickname)\n            });\n            return { success: true };\n        }\n        else {\n            console.error(\"disconnectRoom error\");\n            return { success: false };\n        }\n    }\n    catch (error) {\n        console.error(error);\n        return { success: false };\n    }\n}\n\nexports.accessRoom = async ({ roomId, password }) => {\n    let correct = false;\n    let success = false;\n    let vacancy = false;\n    if (isString(roomId) &&\n        isString(password)) {\n        const encrypted = crypto.createHmac('sha1', config.secret)\n            .update(password)\n            .digest('base64')\n        const result = await db.collection('rooms').doc(roomId).get();\n        const { password: roomPassword, roomLimit, guestList } = result.data();\n        if (!result.empty) {\n            success = true;\n            if (encrypted === roomPassword) {\n                correct = true;\n            }\n            console.log('------------accessroom start')\n            console.log(roomLimit)\n            console.log(guestList.length)\n            console.log('------------ accessroom end')\n            vacancy = roomLimit > guestList.length\n        }\n        // console.log(\"get Object Of Room : \", result)\n    }\n    else {\n        console.error(\"getObjectOfRoom error\");\n    }\n    return { correct, success, vacancy };\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/Common/fireBaseDB/room.js b/backend/Common/fireBaseDB/room.js
--- a/backend/Common/fireBaseDB/room.js	(revision 8e7f3c6ea766a7ca7f223bff6400d9764dfbb96b)
+++ b/backend/Common/fireBaseDB/room.js	(date 1633329923086)
@@ -23,7 +23,7 @@
                 roomLimit,
             } = room;
             const res = db.collection("rooms");
-            const encrypted = crypto.createHmac('sha1', config.secret)
+            const encrypted = crypto.createHmac('sha512', config.secret)
                 .update(password)
                 .digest('base64')
             const addReturn = await res.add({
@@ -136,7 +136,7 @@
     let vacancy = false;
     if (isString(roomId) &&
         isString(password)) {
-        const encrypted = crypto.createHmac('sha1', config.secret)
+        const encrypted = crypto.createHmac('sha512', config.secret)
             .update(password)
             .digest('base64')
         const result = await db.collection('rooms').doc(roomId).get();
